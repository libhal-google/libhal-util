<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>libhal-util: hal Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px;">
              <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">libhal-util
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part --><!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacehal.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">hal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehal_1_1bit"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal_1_1bit.html">bit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacehal_1_1stream"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal_1_1stream.html">stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhal_1_1bit__limits.html">bit_limits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to std::numeric_limits&lt;T&gt; except that this object can give properties of integral types of arbitrary bit widths.  <a href="structhal_1_1bit__limits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1can__router.html">can_router</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Route CAN messages received on the can bus to callbacks based on ID.  <a href="classhal_1_1can__router.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1move__interceptor.html">move_interceptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to perform changes on an object its move constructor is executed.  <a href="classhal_1_1move__interceptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1overflow__counter.html">overflow_counter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend a counter's count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length.  <a href="classhal_1_1overflow__counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1read__into.html">read_into</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking callable for reading serial data into a buffer.  <a href="classhal_1_1read__into.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1read__uint32.html">read_uint32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from serial port and convert to integer.  <a href="classhal_1_1read__uint32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1read__upto.html">read_upto</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard received bytes until the sequence is found.  <a href="classhal_1_1read__upto.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1skip__past.html">skip_past</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard received bytes until the sequence is found.  <a href="classhal_1_1skip__past.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1static__callable.html">static_callable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General class which will be used to allow for signature to be used and then split by the below class.  <a href="classhal_1_1static__callable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4.html">static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classhal_1_1static__callable.html" title="General class which will be used to allow for signature to be used and then split by the below class.">static_callable</a> with the return type and arguments split up.  <a href="classhal_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1static__list.html">static_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classhal_1_1static__list.html" title="static_list is a non-owning non-allocating doubly linked list container with O(1) memory utilization.">static_list</a> is a non-owning non-allocating doubly linked list container with O(1) memory utilization.  <a href="classhal_1_1static__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhal_1_1steady__clock__timeout.html">steady_clock_timeout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout object based on hal::steady_clock.  <a href="classhal_1_1steady__clock__timeout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concepthal_1_1convertible__to__bytes.html">convertible_to_bytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concepthal_1_1enumeration.html">enumeration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">concept for enumeration types <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concepthal_1_1byte__stream.html">byte_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for a byte stream callable object. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abc5ba0c7349a43a7d68cc2960f871ebc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc5ba0c7349a43a7d68cc2960f871ebc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::span&lt; hal::byte &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#abc5ba0c7349a43a7d68cc2960f871ebc">as_writable_bytes</a> (T *p_address, size_t p_number_of_elements)</td></tr>
<tr class="separator:abc5ba0c7349a43a7d68cc2960f871ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7facad0d80497e875c8fcb9a764ae278"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7facad0d80497e875c8fcb9a764ae278"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::span&lt; const hal::byte &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#a7facad0d80497e875c8fcb9a764ae278">as_bytes</a> (const T *p_address, size_t p_number_of_elements)</td></tr>
<tr class="separator:a7facad0d80497e875c8fcb9a764ae278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c57d270d9d9b47275f58a752c57e272"><td class="memItemLeft" align="right" valign="top">constexpr std::span&lt; hal::byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a8c57d270d9d9b47275f58a752c57e272">as_writable_bytes</a> (convertible_to_bytes auto &amp;p_container)</td></tr>
<tr class="separator:a8c57d270d9d9b47275f58a752c57e272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e786d23767c6a5285a103f1a691d52e"><td class="memItemLeft" align="right" valign="top">constexpr std::span&lt; const hal::byte &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a4e786d23767c6a5285a103f1a691d52e">as_bytes</a> (const convertible_to_bytes auto &amp;p_container)</td></tr>
<tr class="separator:a4e786d23767c6a5285a103f1a691d52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dfaa496cc1c025b4bb28abc39e451e2"><td class="memTemplParams" colspan="2">template&lt;size_t BitWidth, std::integral T&gt; </td></tr>
<tr class="memitem:ga3dfaa496cc1c025b4bb28abc39e451e2"><td class="memTemplItemLeft" align="right" valign="top">consteval T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#ga3dfaa496cc1c025b4bb28abc39e451e2">generate_field_of_ones</a> () noexcept</td></tr>
<tr class="memdesc:ga3dfaa496cc1c025b4bb28abc39e451e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mask of 1s at compile time.  <a href="group__utility.html#ga3dfaa496cc1c025b4bb28abc39e451e2">More...</a><br /></td></tr>
<tr class="separator:ga3dfaa496cc1c025b4bb28abc39e451e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c94d8f98d4151cf8bf474d7926bb8b9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a9c94d8f98d4151cf8bf474d7926bb8b9">operator==</a> (const can::settings &amp;p_lhs, const can::settings &amp;p_rhs) noexcept</td></tr>
<tr class="separator:a9c94d8f98d4151cf8bf474d7926bb8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f87be664de29155ed110be8f1f3eae6"><td class="memItemLeft" align="right" valign="top">constexpr std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a6f87be664de29155ed110be8f1f3eae6">bit_width</a> (const can::settings &amp;p_settings) noexcept</td></tr>
<tr class="separator:a6f87be664de29155ed110be8f1f3eae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef3d8d0cbc4b1284e4203f9cdf52e78"><td class="memItemLeft" align="right" valign="top">constexpr std::optional&lt; std::uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a1ef3d8d0cbc4b1284e4203f9cdf52e78">is_valid</a> (const can::settings &amp;p_settings, hertz p_operating_frequency) noexcept</td></tr>
<tr class="memdesc:a1ef3d8d0cbc4b1284e4203f9cdf52e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate configuration settings against an operating frequency.  <a href="namespacehal.html#a1ef3d8d0cbc4b1284e4203f9cdf52e78">More...</a><br /></td></tr>
<tr class="separator:a1ef3d8d0cbc4b1284e4203f9cdf52e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eba956ee13962b21698a6f68c65a74"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#aa0eba956ee13962b21698a6f68c65a74">operator==</a> (const can::message_t &amp;p_lhs, const can::message_t &amp;p_rhs) noexcept</td></tr>
<tr class="separator:aa0eba956ee13962b21698a6f68c65a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88cd03f91cf5b2ae267c13d6c86af18"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#aa88cd03f91cf5b2ae267c13d6c86af18">value</a> (enumeration auto p_enum_value) noexcept</td></tr>
<tr class="memdesc:aa88cd03f91cf5b2ae267c13d6c86af18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to convert an enum to its integral value.  <a href="namespacehal.html#aa88cd03f91cf5b2ae267c13d6c86af18">More...</a><br /></td></tr>
<tr class="separator:aa88cd03f91cf5b2ae267c13d6c86af18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7701083fe3fdb39b9a187ca9993e9b6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#af7701083fe3fdb39b9a187ca9993e9b6">operator==</a> (const i2c::settings &amp;p_lhs, const i2c::settings &amp;p_rhs) noexcept</td></tr>
<tr class="separator:af7701083fe3fdb39b9a187ca9993e9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602272331e4e2f84843e2fe34e83cca6"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a602272331e4e2f84843e2fe34e83cca6">write</a> (i2c &amp;p_i2c, hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, timeout auto p_timeout=hal::never_timeout()) noexcept</td></tr>
<tr class="memdesc:a602272331e4e2f84843e2fe34e83cca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">write data to a target device on the i2c bus  <a href="namespacehal.html#a602272331e4e2f84843e2fe34e83cca6">More...</a><br /></td></tr>
<tr class="separator:a602272331e4e2f84843e2fe34e83cca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00694e558039dbf0a2e4f2a438754e10"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a00694e558039dbf0a2e4f2a438754e10">read</a> (i2c &amp;p_i2c, hal::byte p_address, std::span&lt; hal::byte &gt; p_data_in, timeout auto p_timeout=hal::never_timeout()) noexcept</td></tr>
<tr class="memdesc:a00694e558039dbf0a2e4f2a438754e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">read bytes from target device on i2c bus  <a href="namespacehal.html#a00694e558039dbf0a2e4f2a438754e10">More...</a><br /></td></tr>
<tr class="separator:a00694e558039dbf0a2e4f2a438754e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaee8290b9ba7d512d6f8a724e99d06c"><td class="memTemplParams" colspan="2">template&lt;size_t BytesToRead&gt; </td></tr>
<tr class="memitem:afaee8290b9ba7d512d6f8a724e99d06c"><td class="memTemplItemLeft" align="right" valign="top">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#afaee8290b9ba7d512d6f8a724e99d06c">read</a> (i2c &amp;p_i2c, hal::byte p_address, timeout auto p_timeout=hal::never_timeout()) noexcept</td></tr>
<tr class="memdesc:afaee8290b9ba7d512d6f8a724e99d06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return array of read bytes from target device on i2c bus  <a href="namespacehal.html#afaee8290b9ba7d512d6f8a724e99d06c">More...</a><br /></td></tr>
<tr class="separator:afaee8290b9ba7d512d6f8a724e99d06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccf0a18afda016d4d6a05165bc0b0ab"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#adccf0a18afda016d4d6a05165bc0b0ab">write_then_read</a> (i2c &amp;p_i2c, hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, timeout auto p_timeout=hal::never_timeout()) noexcept</td></tr>
<tr class="memdesc:adccf0a18afda016d4d6a05165bc0b0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">write and then read bytes from target device on i2c bus  <a href="namespacehal.html#adccf0a18afda016d4d6a05165bc0b0ab">More...</a><br /></td></tr>
<tr class="separator:adccf0a18afda016d4d6a05165bc0b0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd61760afda4a75284d67f433a2fa50"><td class="memTemplParams" colspan="2">template&lt;size_t BytesToRead&gt; </td></tr>
<tr class="memitem:a3dd61760afda4a75284d67f433a2fa50"><td class="memTemplItemLeft" align="right" valign="top">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#a3dd61760afda4a75284d67f433a2fa50">write_then_read</a> (i2c &amp;p_i2c, hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, timeout auto p_timeout=hal::never_timeout()) noexcept</td></tr>
<tr class="memdesc:a3dd61760afda4a75284d67f433a2fa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">write and then return an array of read bytes from target device on i2c bus  <a href="namespacehal.html#a3dd61760afda4a75284d67f433a2fa50">More...</a><br /></td></tr>
<tr class="separator:a3dd61760afda4a75284d67f433a2fa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ce95a0f68875e29428e13cc53c3387"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#ad1ce95a0f68875e29428e13cc53c3387">probe</a> (i2c &amp;p_i2c, hal::byte p_address) noexcept</td></tr>
<tr class="memdesc:ad1ce95a0f68875e29428e13cc53c3387"><td class="mdescLeft">&#160;</td><td class="mdescRight">probe the i2c bus to see if a device exists  <a href="namespacehal.html#ad1ce95a0f68875e29428e13cc53c3387">More...</a><br /></td></tr>
<tr class="separator:ad1ce95a0f68875e29428e13cc53c3387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61345e935d9024b56cf226c3dbddc6ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a61345e935d9024b56cf226c3dbddc6ec">operator==</a> (const input_pin::settings &amp;p_lhs, const input_pin::settings &amp;p_rhs) noexcept</td></tr>
<tr class="separator:a61345e935d9024b56cf226c3dbddc6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7595bc96003d3eaec4fe2b5c566ace1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#ae7595bc96003d3eaec4fe2b5c566ace1">operator==</a> (const interrupt_pin::settings &amp;p_lhs, const interrupt_pin::settings &amp;p_rhs) noexcept</td></tr>
<tr class="separator:ae7595bc96003d3eaec4fe2b5c566ace1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6a3aec0a1f3227cfc539f8c57e0f40"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#ada6a3aec0a1f3227cfc539f8c57e0f40">map</a> (float p_target, std::pair&lt; float, float &gt; p_input_range, std::pair&lt; float, float &gt; p_output_range) noexcept</td></tr>
<tr class="memdesc:ada6a3aec0a1f3227cfc539f8c57e0f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an target value [x] from an input range [a,b] to an output range [c,d].  <a href="namespacehal.html#ada6a3aec0a1f3227cfc539f8c57e0f40">More...</a><br /></td></tr>
<tr class="separator:ada6a3aec0a1f3227cfc539f8c57e0f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fd2fa3493be5292dc4ea824e944d90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43fd2fa3493be5292dc4ea824e944d90"><td class="memTemplItemLeft" align="right" valign="top">result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#a43fd2fa3493be5292dc4ea824e944d90">multiply</a> (T p_lhs, T p_rhs) noexcept</td></tr>
<tr class="memdesc:a43fd2fa3493be5292dc4ea824e944d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform multiply operation and return an error code <code>std::errc::result_out_of_range</code> if the two values when multiplied would overflow the containing value.  <a href="namespacehal.html#a43fd2fa3493be5292dc4ea824e944d90">More...</a><br /></td></tr>
<tr class="separator:a43fd2fa3493be5292dc4ea824e944d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac86abb9a38f4962ded5507e15dca4b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac86abb9a38f4962ded5507e15dca4b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#aac86abb9a38f4962ded5507e15dca4b9">absolute_value</a> (T p_value) noexcept</td></tr>
<tr class="memdesc:aac86abb9a38f4962ded5507e15dca4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic absolute value function that works for integer types.  <a href="namespacehal.html#aac86abb9a38f4962ded5507e15dca4b9">More...</a><br /></td></tr>
<tr class="separator:aac86abb9a38f4962ded5507e15dca4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a3550a3236310f20b92eacf593c2f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58a3550a3236310f20b92eacf593c2f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#a58a3550a3236310f20b92eacf593c2f0">rounding_division</a> (T p_numerator, T p_denominator) noexcept</td></tr>
<tr class="memdesc:a58a3550a3236310f20b92eacf593c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5.  <a href="namespacehal.html#a58a3550a3236310f20b92eacf593c2f0">More...</a><br /></td></tr>
<tr class="separator:a58a3550a3236310f20b92eacf593c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd717bac7dd9983e8027bd45b7c3d15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afcd717bac7dd9983e8027bd45b7c3d15"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#afcd717bac7dd9983e8027bd45b7c3d15">distance</a> (T p_left, T p_right) noexcept</td></tr>
<tr class="memdesc:afcd717bac7dd9983e8027bd45b7c3d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance between two values (L1 Norm or Manhattan distance), the absolute value of their difference.  <a href="namespacehal.html#afcd717bac7dd9983e8027bd45b7c3d15">More...</a><br /></td></tr>
<tr class="separator:afcd717bac7dd9983e8027bd45b7c3d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05557d15ab4e9b475f9c33d6cae0be8"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:ad05557d15ab4e9b475f9c33d6cae0be8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::make_unsigned_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#ad05557d15ab4e9b475f9c33d6cae0be8">distance</a> (T p_left, T p_right) noexcept</td></tr>
<tr class="memdesc:ad05557d15ab4e9b475f9c33d6cae0be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance between two values (L1 Norm or Manhattan distance), the absolute value of their difference.  <a href="namespacehal.html#ad05557d15ab4e9b475f9c33d6cae0be8">More...</a><br /></td></tr>
<tr class="separator:ad05557d15ab4e9b475f9c33d6cae0be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edbd3360d379f8c1864447f60a79271"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a0edbd3360d379f8c1864447f60a79271">equals</a> (std::floating_point auto p_value1, std::floating_point auto p_value2, float p_epsilon=1e-9f)</td></tr>
<tr class="memdesc:a0edbd3360d379f8c1864447f60a79271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two values are equal within a relative error.  <a href="namespacehal.html#a0edbd3360d379f8c1864447f60a79271">More...</a><br /></td></tr>
<tr class="separator:a0edbd3360d379f8c1864447f60a79271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b9e7de64519263a90bff8e094f25dd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a66b9e7de64519263a90bff8e094f25dd">operator==</a> (const output_pin::settings &amp;p_lhs, const output_pin::settings &amp;p_rhs) noexcept</td></tr>
<tr class="separator:a66b9e7de64519263a90bff8e094f25dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b05743dd9eeecc7fab83b6f472c9397"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a2b05743dd9eeecc7fab83b6f472c9397">operator==</a> (const serial::settings &amp;p_lhs, const serial::settings &amp;p_rhs) noexcept</td></tr>
<tr class="separator:a2b05743dd9eeecc7fab83b6f472c9397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcfdc8a8fa26b039d5a8a6f9b6b6962"><td class="memItemLeft" align="right" valign="top">result&lt; serial::write_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a9fcfdc8a8fa26b039d5a8a6f9b6b6962">write_partial</a> (serial &amp;p_serial, std::span&lt; const hal::byte &gt; p_data_out) noexcept</td></tr>
<tr class="memdesc:a9fcfdc8a8fa26b039d5a8a6f9b6b6962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to a serial port.  <a href="namespacehal.html#a9fcfdc8a8fa26b039d5a8a6f9b6b6962">More...</a><br /></td></tr>
<tr class="separator:a9fcfdc8a8fa26b039d5a8a6f9b6b6962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9686cb634f86ed068a43ea5bb5224073"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a9686cb634f86ed068a43ea5bb5224073">write</a> (serial &amp;p_serial, std::span&lt; const hal::byte &gt; p_data_out) noexcept</td></tr>
<tr class="memdesc:a9686cb634f86ed068a43ea5bb5224073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to a serial port.  <a href="namespacehal.html#a9686cb634f86ed068a43ea5bb5224073">More...</a><br /></td></tr>
<tr class="separator:a9686cb634f86ed068a43ea5bb5224073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2952837cd8d503a962e7edf748737925"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a2952837cd8d503a962e7edf748737925">write</a> (serial &amp;p_serial, std::string_view p_data_out) noexcept</td></tr>
<tr class="memdesc:a2952837cd8d503a962e7edf748737925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write std::span of const char to a serial port.  <a href="namespacehal.html#a2952837cd8d503a962e7edf748737925">More...</a><br /></td></tr>
<tr class="separator:a2952837cd8d503a962e7edf748737925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f116057547375e7bcdc6f29ef3786c"><td class="memItemLeft" align="right" valign="top">result&lt; std::span&lt; hal::byte &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a58f116057547375e7bcdc6f29ef3786c">read</a> (serial &amp;p_serial, std::span&lt; hal::byte &gt; p_data_in, timeout auto p_timeout) noexcept</td></tr>
<tr class="memdesc:a58f116057547375e7bcdc6f29ef3786c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from a serial port.  <a href="namespacehal.html#a58f116057547375e7bcdc6f29ef3786c">More...</a><br /></td></tr>
<tr class="separator:a58f116057547375e7bcdc6f29ef3786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a286f05a92dbc946d4e0a79db6683da"><td class="memTemplParams" colspan="2">template&lt;size_t BytesToRead&gt; </td></tr>
<tr class="memitem:a1a286f05a92dbc946d4e0a79db6683da"><td class="memTemplItemLeft" align="right" valign="top">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#a1a286f05a92dbc946d4e0a79db6683da">read</a> (serial &amp;p_serial, timeout auto p_timeout) noexcept</td></tr>
<tr class="memdesc:a1a286f05a92dbc946d4e0a79db6683da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bytes from a serial port and return an array.  <a href="namespacehal.html#a1a286f05a92dbc946d4e0a79db6683da">More...</a><br /></td></tr>
<tr class="separator:a1a286f05a92dbc946d4e0a79db6683da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9abf5cca98ceab03b2bcae88c8231a"><td class="memItemLeft" align="right" valign="top">result&lt; std::span&lt; hal::byte &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a2d9abf5cca98ceab03b2bcae88c8231a">write_then_read</a> (serial &amp;p_serial, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, timeout auto p_timeout) noexcept</td></tr>
<tr class="memdesc:a2d9abf5cca98ceab03b2bcae88c8231a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a write then read transaction over serial.  <a href="namespacehal.html#a2d9abf5cca98ceab03b2bcae88c8231a">More...</a><br /></td></tr>
<tr class="separator:a2d9abf5cca98ceab03b2bcae88c8231a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56cced130d5fe0233e0035616209b52"><td class="memTemplParams" colspan="2">template&lt;size_t BytesToRead&gt; </td></tr>
<tr class="memitem:aa56cced130d5fe0233e0035616209b52"><td class="memTemplItemLeft" align="right" valign="top">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#aa56cced130d5fe0233e0035616209b52">write_then_read</a> (serial &amp;p_serial, std::span&lt; const hal::byte &gt; p_data_out, timeout auto p_timeout) noexcept</td></tr>
<tr class="memdesc:aa56cced130d5fe0233e0035616209b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a write then read transaction over serial.  <a href="namespacehal.html#aa56cced130d5fe0233e0035616209b52">More...</a><br /></td></tr>
<tr class="separator:aa56cced130d5fe0233e0035616209b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0c567f9afda7f9d9e1ba91f60a83aa"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#abc0c567f9afda7f9d9e1ba91f60a83aa">operator==</a> (const spi::settings &amp;p_lhs, const spi::settings &amp;p_rhs) noexcept</td></tr>
<tr class="separator:abc0c567f9afda7f9d9e1ba91f60a83aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21efc78280c81eac00f3ef778de2dedf"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a21efc78280c81eac00f3ef778de2dedf">write</a> (spi &amp;p_spi, std::span&lt; const hal::byte &gt; p_data_out) noexcept</td></tr>
<tr class="memdesc:a21efc78280c81eac00f3ef778de2dedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the SPI bus and ignore data sent from peripherals on the bus.  <a href="namespacehal.html#a21efc78280c81eac00f3ef778de2dedf">More...</a><br /></td></tr>
<tr class="separator:a21efc78280c81eac00f3ef778de2dedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7f7d46ffb8abf2bb679b1516926160"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a8a7f7d46ffb8abf2bb679b1516926160">read</a> (spi &amp;p_spi, std::span&lt; hal::byte &gt; p_data_in, hal::byte p_filler=spi::default_filler) noexcept</td></tr>
<tr class="memdesc:a8a7f7d46ffb8abf2bb679b1516926160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the SPI bus.  <a href="namespacehal.html#a8a7f7d46ffb8abf2bb679b1516926160">More...</a><br /></td></tr>
<tr class="separator:a8a7f7d46ffb8abf2bb679b1516926160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6b09a90535fd11225c129264d20d0a"><td class="memTemplParams" colspan="2">template&lt;size_t BytesToRead&gt; </td></tr>
<tr class="memitem:afb6b09a90535fd11225c129264d20d0a"><td class="memTemplItemLeft" align="right" valign="top">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#afb6b09a90535fd11225c129264d20d0a">read</a> (spi &amp;p_spi, hal::byte p_filler=spi::default_filler) noexcept</td></tr>
<tr class="memdesc:afb6b09a90535fd11225c129264d20d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the SPI bus and return a std::array of bytes.  <a href="namespacehal.html#afb6b09a90535fd11225c129264d20d0a">More...</a><br /></td></tr>
<tr class="separator:afb6b09a90535fd11225c129264d20d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0304f6c421db748182386f3dc4547916"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a0304f6c421db748182386f3dc4547916">write_then_read</a> (spi &amp;p_spi, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, hal::byte p_filler=spi::default_filler) noexcept</td></tr>
<tr class="memdesc:a0304f6c421db748182386f3dc4547916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes.  <a href="namespacehal.html#a0304f6c421db748182386f3dc4547916">More...</a><br /></td></tr>
<tr class="separator:a0304f6c421db748182386f3dc4547916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5414224d552a6e33ad7c7a49c44bc8b"><td class="memTemplParams" colspan="2">template&lt;size_t BytesToRead&gt; </td></tr>
<tr class="memitem:ae5414224d552a6e33ad7c7a49c44bc8b"><td class="memTemplItemLeft" align="right" valign="top">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#ae5414224d552a6e33ad7c7a49c44bc8b">write_then_read</a> (spi &amp;p_spi, std::span&lt; const hal::byte &gt; p_data_out, hal::byte p_filler=spi::default_filler) noexcept</td></tr>
<tr class="memdesc:ae5414224d552a6e33ad7c7a49c44bc8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes.  <a href="namespacehal.html#ae5414224d552a6e33ad7c7a49c44bc8b">More...</a><br /></td></tr>
<tr class="separator:ae5414224d552a6e33ad7c7a49c44bc8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c92db3eb5ae3b8e67f16261a6f71d91"><td class="memItemLeft" align="right" valign="top">result&lt; <a class="el" href="classhal_1_1steady__clock__timeout.html">hal::steady_clock_timeout</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a8c92db3eb5ae3b8e67f16261a6f71d91">create_timeout</a> (hal::steady_clock &amp;p_steady_clock, hal::time_duration p_duration)</td></tr>
<tr class="memdesc:a8c92db3eb5ae3b8e67f16261a6f71d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a timeout object based on hal::steady_clock.  <a href="namespacehal.html#a8c92db3eb5ae3b8e67f16261a6f71d91">More...</a><br /></td></tr>
<tr class="separator:a8c92db3eb5ae3b8e67f16261a6f71d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cd2610c280e615d52e03d83dad28f6"><td class="memItemLeft" align="right" valign="top">status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a80cd2610c280e615d52e03d83dad28f6">delay</a> (hal::steady_clock &amp;p_steady_clock, hal::time_duration p_duration) noexcept</td></tr>
<tr class="memdesc:a80cd2610c280e615d52e03d83dad28f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay execution for a duration of time using a hardware steady_clock.  <a href="namespacehal.html#a80cd2610c280e615d52e03d83dad28f6">More...</a><br /></td></tr>
<tr class="separator:a80cd2610c280e615d52e03d83dad28f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a8c1d4bb482a3798af832c843e95c1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#ad1a8c1d4bb482a3798af832c843e95c1">timeout_generator</a> (hal::steady_clock &amp;p_steady_clock)</td></tr>
<tr class="memdesc:ad1a8c1d4bb482a3798af832c843e95c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a function that, when passed a duration, returns a timeout.  <a href="namespacehal.html#ad1a8c1d4bb482a3798af832c843e95c1">More...</a><br /></td></tr>
<tr class="separator:ad1a8c1d4bb482a3798af832c843e95c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea8e36f9e6dbfd8e2f999c7ae052143"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a5ea8e36f9e6dbfd8e2f999c7ae052143">terminated</a> (byte_stream auto p_byte_stream_object)</td></tr>
<tr class="memdesc:a5ea8e36f9e6dbfd8e2f999c7ae052143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if a byte stream object has finished its work.  <a href="namespacehal.html#a5ea8e36f9e6dbfd8e2f999c7ae052143">More...</a><br /></td></tr>
<tr class="separator:a5ea8e36f9e6dbfd8e2f999c7ae052143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829d948a20f6466095edce347d7feb3b"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a829d948a20f6466095edce347d7feb3b">to_string</a> (work_state p_state)</td></tr>
<tr class="separator:a829d948a20f6466095edce347d7feb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c394730b2a8d131a48e6f033e26293c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a7c394730b2a8d131a48e6f033e26293c">terminated</a> (work_state p_state)</td></tr>
<tr class="separator:a7c394730b2a8d131a48e6f033e26293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fd20564d6169140e6ac2523fb98f5f"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:a72fd20564d6169140e6ac2523fb98f5f"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#a72fd20564d6169140e6ac2523fb98f5f">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;p_ostream, const work_state &amp;p_state)</td></tr>
<tr class="separator:a72fd20564d6169140e6ac2523fb98f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5c3782a92312131a5a7824ee6d1801"><td class="memItemLeft" align="right" valign="top">result&lt; work_state &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#abd5c3782a92312131a5a7824ee6d1801">try_until</a> (worker auto &amp;p_worker, timeout auto p_timeout) noexcept</td></tr>
<tr class="memdesc:abd5c3782a92312131a5a7824ee6d1801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeatedly call a worker function until it has reached a terminal state or a timeout has been reached.  <a href="namespacehal.html#abd5c3782a92312131a5a7824ee6d1801">More...</a><br /></td></tr>
<tr class="separator:abd5c3782a92312131a5a7824ee6d1801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb2bc5d9203d47298c18293666a718b"><td class="memItemLeft" align="right" valign="top">result&lt; work_state &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a6fb2bc5d9203d47298c18293666a718b">try_until</a> (worker auto &amp;&amp;p_worker, timeout auto p_timeout) noexcept</td></tr>
<tr class="memdesc:a6fb2bc5d9203d47298c18293666a718b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeatedly call a worker function until it has reached a terminal state or a timeout has been reached.  <a href="namespacehal.html#a6fb2bc5d9203d47298c18293666a718b">More...</a><br /></td></tr>
<tr class="separator:a6fb2bc5d9203d47298c18293666a718b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8c4111664297ec9a8af392a3ee03a4"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a9e8c4111664297ec9a8af392a3ee03a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; char, N+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#a9e8c4111664297ec9a8af392a3ee03a4">to_array</a> (std::string_view p_view) noexcept</td></tr>
<tr class="memdesc:a9e8c4111664297ec9a8af392a3ee03a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string_view into a std::array of N number of characters.  <a href="namespacehal.html#a9e8c4111664297ec9a8af392a3ee03a4">More...</a><br /></td></tr>
<tr class="separator:a9e8c4111664297ec9a8af392a3ee03a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7dbaa1167fbee1c7a3387de676a749"><td class="memItemLeft" align="right" valign="top">constexpr std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#a4f7dbaa1167fbee1c7a3387de676a749">cycles_per</a> (hertz p_source, hal::time_duration p_duration) noexcept</td></tr>
<tr class="memdesc:a4f7dbaa1167fbee1c7a3387de676a749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of cycles of this frequency within the time duration. This function is meant for timers to determine how many count cycles are needed to reach a particular time duration at this frequency.  <a href="namespacehal.html#a4f7dbaa1167fbee1c7a3387de676a749">More...</a><br /></td></tr>
<tr class="separator:a4f7dbaa1167fbee1c7a3387de676a749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ad6db29189e74fcb1a49dc801897b3"><td class="memTemplParams" colspan="2">template&lt;typename Period &gt; </td></tr>
<tr class="memitem:a80ad6db29189e74fcb1a49dc801897b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::chrono::duration&lt; int64_t, Period &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#a80ad6db29189e74fcb1a49dc801897b3">wavelength</a> (hertz p_source)</td></tr>
<tr class="memdesc:a80ad6db29189e74fcb1a49dc801897b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the wavelength in seconds.  <a href="namespacehal.html#a80ad6db29189e74fcb1a49dc801897b3">More...</a><br /></td></tr>
<tr class="separator:a80ad6db29189e74fcb1a49dc801897b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac884b3e7857a710a51651bf449c5dd86"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#ac884b3e7857a710a51651bf449c5dd86">wavelength</a> (hertz p_source)</td></tr>
<tr class="memdesc:ac884b3e7857a710a51651bf449c5dd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the wavelength in seconds as a float.  <a href="namespacehal.html#ac884b3e7857a710a51651bf449c5dd86">More...</a><br /></td></tr>
<tr class="separator:ac884b3e7857a710a51651bf449c5dd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e3226fbdfad6db38eb093f1420489c"><td class="memItemLeft" align="right" valign="top">result&lt; std::chrono::nanoseconds &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehal.html#ad3e3226fbdfad6db38eb093f1420489c">duration_from_cycles</a> (hertz p_source, uint32_t p_cycles) noexcept</td></tr>
<tr class="memdesc:ad3e3226fbdfad6db38eb093f1420489c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the amount of time it takes a frequency to oscillate a number of cycles.  <a href="namespacehal.html#ad3e3226fbdfad6db38eb093f1420489c">More...</a><br /></td></tr>
<tr class="separator:ad3e3226fbdfad6db38eb093f1420489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8aaf22d9bdddd575788368f47a33889"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits &gt; </td></tr>
<tr class="memitem:aa8aaf22d9bdddd575788368f47a33889"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehal.html#aa8aaf22d9bdddd575788368f47a33889">operator&lt;&lt;</a> (std::basic_ostream&lt; CharT, Traits &gt; &amp;p_ostream, const hal::byte &amp;p_byte)</td></tr>
<tr class="memdesc:aa8aaf22d9bdddd575788368f47a33889"><td class="mdescLeft">&#160;</td><td class="mdescRight">print byte type using ostreams  <a href="namespacehal.html#aa8aaf22d9bdddd575788368f47a33889">More...</a><br /></td></tr>
<tr class="separator:aa8aaf22d9bdddd575788368f47a33889"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aac86abb9a38f4962ded5507e15dca4b9" name="aac86abb9a38f4962ded5507e15dca4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac86abb9a38f4962ded5507e15dca4b9">&#9670;&#160;</a></span>absolute_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T hal::absolute_value </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic absolute value function that works for integer types. </p>
<p >Preferred this over the C API for rounding numbers such as abs(), labs() and llabs(). This function relieves the need in template code to check the type of the integer and select the correct function to call.</p>
<p >NOTE: If p_value is minimum negative number of type T then the resulting return value will be the maximum positive number represented by T. For example, INT32_MIN is 2147483648 where as INT32_MAX is 2147483647. The absolute value of INT32_MIN is 1 greater than INT32_MAX. To prevent overflow, passing INT32_MIN will simply return back INT32_MAX.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- integral type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value</td><td>- integer value to be made positive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr auto - positive representation of the integer </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_aac86abb9a38f4962ded5507e15dca4b9_icgraph.svg" width="336" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4e786d23767c6a5285a103f1a691d52e" name="a4e786d23767c6a5285a103f1a691d52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e786d23767c6a5285a103f1a691d52e">&#9670;&#160;</a></span>as_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::span&lt; const hal::byte &gt; hal::as_bytes </td>
          <td>(</td>
          <td class="paramtype">const convertible_to_bytes auto &amp;&#160;</td>
          <td class="paramname"><em>p_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a4e786d23767c6a5285a103f1a691d52e_cgraph.svg" width="254" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7facad0d80497e875c8fcb9a764ae278" name="a7facad0d80497e875c8fcb9a764ae278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7facad0d80497e875c8fcb9a764ae278">&#9670;&#160;</a></span>as_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::span&lt; const hal::byte &gt; hal::as_bytes </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p_number_of_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a7facad0d80497e875c8fcb9a764ae278_icgraph.svg" width="254" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8c57d270d9d9b47275f58a752c57e272" name="a8c57d270d9d9b47275f58a752c57e272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c57d270d9d9b47275f58a752c57e272">&#9670;&#160;</a></span>as_writable_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::span&lt; hal::byte &gt; hal::as_writable_bytes </td>
          <td>(</td>
          <td class="paramtype">convertible_to_bytes auto &amp;&#160;</td>
          <td class="paramname"><em>p_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a8c57d270d9d9b47275f58a752c57e272_cgraph.svg" width="358" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abc5ba0c7349a43a7d68cc2960f871ebc" name="abc5ba0c7349a43a7d68cc2960f871ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5ba0c7349a43a7d68cc2960f871ebc">&#9670;&#160;</a></span>as_writable_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::span&lt; hal::byte &gt; hal::as_writable_bytes </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p_number_of_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_abc5ba0c7349a43a7d68cc2960f871ebc_icgraph.svg" width="358" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a6f87be664de29155ed110be8f1f3eae6" name="a6f87be664de29155ed110be8f1f3eae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f87be664de29155ed110be8f1f3eae6">&#9670;&#160;</a></span>bit_width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint16_t hal::bit_width </td>
          <td>(</td>
          <td class="paramtype">const can::settings &amp;&#160;</td>
          <td class="paramname"><em>p_settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a6f87be664de29155ed110be8f1f3eae6_icgraph.svg" width="246" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8c92db3eb5ae3b8e67f16261a6f71d91" name="a8c92db3eb5ae3b8e67f16261a6f71d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c92db3eb5ae3b8e67f16261a6f71d91">&#9670;&#160;</a></span>create_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; <a class="el" href="classhal_1_1steady__clock__timeout.html">hal::steady_clock_timeout</a> &gt; hal::create_timeout </td>
          <td>(</td>
          <td class="paramtype">hal::steady_clock &amp;&#160;</td>
          <td class="paramname"><em>p_steady_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::time_duration&#160;</td>
          <td class="paramname"><em>p_duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a timeout object based on hal::steady_clock. </p>
<p >NOTE: Multiple timeout objects can be made from a single steady_clock without influencing other timeout objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_steady_clock</td><td>- hal::steady_clock implementation </td></tr>
    <tr><td class="paramname">p_duration</td><td>- amount of time until timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;hal::steady_clock_timeout&gt; - timeout object </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a8c92db3eb5ae3b8e67f16261a6f71d91_cgraph.svg" width="360" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a8c92db3eb5ae3b8e67f16261a6f71d91_icgraph.svg" width="339" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4f7dbaa1167fbee1c7a3387de676a749" name="a4f7dbaa1167fbee1c7a3387de676a749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7dbaa1167fbee1c7a3387de676a749">&#9670;&#160;</a></span>cycles_per()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::int64_t hal::cycles_per </td>
          <td>(</td>
          <td class="paramtype">hertz&#160;</td>
          <td class="paramname"><em>p_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::time_duration&#160;</td>
          <td class="paramname"><em>p_duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the number of cycles of this frequency within the time duration. This function is meant for timers to determine how many count cycles are needed to reach a particular time duration at this frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_source</td><td>- source frequency </td></tr>
    <tr><td class="paramname">p_duration</td><td>- the amount of time to convert to cycles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::int64_t - number of cycles </dd></dl>

</div>
</div>
<a id="a80cd2610c280e615d52e03d83dad28f6" name="a80cd2610c280e615d52e03d83dad28f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cd2610c280e615d52e03d83dad28f6">&#9670;&#160;</a></span>delay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::delay </td>
          <td>(</td>
          <td class="paramtype">hal::steady_clock &amp;&#160;</td>
          <td class="paramname"><em>p_steady_clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::time_duration&#160;</td>
          <td class="paramname"><em>p_duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delay execution for a duration of time using a hardware steady_clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_steady_clock</td><td>- steady_clock driver </td></tr>
    <tr><td class="paramname">p_duration</td><td>- the amount of time to delay for. Zero or negative time duration will delay for one tick of the p_steady_clock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - if successful, then execution of the program was halted for the p_duration time frame, otherwise, a failure occurred either when creating the timeout from the steady clock or from calling uptime() on the steady clock. In the failure situation, it is unknown how long the program/thread halted for. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a80cd2610c280e615d52e03d83dad28f6_cgraph.svg" width="483" height="68"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a80cd2610c280e615d52e03d83dad28f6_icgraph.svg" width="86" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afcd717bac7dd9983e8027bd45b7c3d15" name="afcd717bac7dd9983e8027bd45b7c3d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd717bac7dd9983e8027bd45b7c3d15">&#9670;&#160;</a></span>distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T hal::distance </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the distance between two values (L1 Norm or Manhattan distance), the absolute value of their difference. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- integral type of the two values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_left</td><td>- the first point of the distance calculation </td></tr>
    <tr><td class="paramname">p_right</td><td>- the second point of the distance calculation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr T - absolute value of the difference between the two points. </dd></dl>

</div>
</div>
<a id="ad05557d15ab4e9b475f9c33d6cae0be8" name="ad05557d15ab4e9b475f9c33d6cae0be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05557d15ab4e9b475f9c33d6cae0be8">&#9670;&#160;</a></span>distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::make_unsigned_t&lt; T &gt; hal::distance </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the distance between two values (L1 Norm or Manhattan distance), the absolute value of their difference. </p>
<p >NOTE: Values cannot exceed int32_t.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- integral type of the two values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_left</td><td>- the first point of the distance calculation </td></tr>
    <tr><td class="paramname">p_right</td><td>- the second point of the distance calculation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr T - absolute value of the difference between the two points. </dd></dl>

</div>
</div>
<a id="ad3e3226fbdfad6db38eb093f1420489c" name="ad3e3226fbdfad6db38eb093f1420489c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e3226fbdfad6db38eb093f1420489c">&#9670;&#160;</a></span>duration_from_cycles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; std::chrono::nanoseconds &gt; hal::duration_from_cycles </td>
          <td>(</td>
          <td class="paramtype">hertz&#160;</td>
          <td class="paramname"><em>p_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>p_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the amount of time it takes a frequency to oscillate a number of cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_source</td><td>- the frequency to compute the cycles from </td></tr>
    <tr><td class="paramname">p_cycles</td><td>- number of cycles within the time duration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::chrono::nanoseconds - time duration based on this frequency and the number of cycles </dd></dl>

</div>
</div>
<a id="a0edbd3360d379f8c1864447f60a79271" name="a0edbd3360d379f8c1864447f60a79271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edbd3360d379f8c1864447f60a79271">&#9670;&#160;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool hal::equals </td>
          <td>(</td>
          <td class="paramtype">std::floating_point auto&#160;</td>
          <td class="paramname"><em>p_value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::floating_point auto&#160;</td>
          <td class="paramname"><em>p_value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p_epsilon</em> = <code>1e-9f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two values are equal within a relative error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_value1</td><td>- First value to compare. </td></tr>
    <tr><td class="paramname">p_value2</td><td>- Second value to compare. </td></tr>
    <tr><td class="paramname">p_epsilon</td><td>- Error margin that the difference is compared to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - difference is less than epsilon </dd>
<dd>
false - difference is more than epsilon </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a0edbd3360d379f8c1864447f60a79271_icgraph.svg" width="252" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1ef3d8d0cbc4b1284e4203f9cdf52e78" name="a1ef3d8d0cbc4b1284e4203f9cdf52e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef3d8d0cbc4b1284e4203f9cdf52e78">&#9670;&#160;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::optional&lt; std::uint32_t &gt; hal::is_valid </td>
          <td>(</td>
          <td class="paramtype">const can::settings &amp;&#160;</td>
          <td class="paramname"><em>p_settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hertz&#160;</td>
          <td class="paramname"><em>p_operating_frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate configuration settings against an operating frequency. </p>
<p >The settings and frequency must follow the following rules:</p>
<ol type="1">
<li>propagation_delay, phase_segment1, phase_segment2 and synchronization_jump_width must be nonzero.</li>
<li>synchronization_jump_width must be the lesser between phase_segment1 and phase_segment2.</li>
<li>The total bit width must be equal to or greater than 8 Tq/bit; the sum of sync_segment, propagation_delay, phase_segment1 and phase_segment2.</li>
<li>The CAN device's operating frequency must be at least 8 times the baud rate to give the minimum.</li>
<li>The ratio between the CAN device's operating frequency and the bit width must be close enough to an integer to produce a usable baud rate prescaler.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_settings</td><td>- settings object to check </td></tr>
    <tr><td class="paramname">p_operating_frequency</td><td>- CAN device operating frequency </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;std::uint32_t&gt; - baud rate prescaler </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a1ef3d8d0cbc4b1284e4203f9cdf52e78_cgraph.svg" width="246" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ada6a3aec0a1f3227cfc539f8c57e0f40" name="ada6a3aec0a1f3227cfc539f8c57e0f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6a3aec0a1f3227cfc539f8c57e0f40">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float hal::map </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; float, float &gt;&#160;</td>
          <td class="paramname"><em>p_input_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; float, float &gt;&#160;</td>
          <td class="paramname"><em>p_output_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map an target value [x] from an input range [a,b] to an output range [c,d]. </p>
<p >Another term for this is an affine transformation which follows this equation: </p><pre class="fragment">                  / d - c \
   y = (x - a) * | --------| + c
                  \ b - a /
</pre><p> For example:</p>
<p >let x = 5.0 let input_range = [0.0, 10.0] let output_range = [100.0, 200.0] The result will be 150.0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_target</td><td>- target value within p_input_range to be mapped to the output range. </td></tr>
    <tr><td class="paramname">p_input_range</td><td>- the input range of p_target </td></tr>
    <tr><td class="paramname">p_output_range</td><td>- the output range to map p_target to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr float - value mapped from input range to the output range. The output is clamped to the output range. </dd></dl>
<pre class="fragment">           / d - c \
</pre><p> y = (x - a) * | -----&mdash;| + c \ b - a /</p>

</div>
</div>
<a id="a43fd2fa3493be5292dc4ea824e944d90" name="a43fd2fa3493be5292dc4ea824e944d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fd2fa3493be5292dc4ea824e944d90">&#9670;&#160;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; T &gt; hal::multiply </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform multiply operation and return an error code <code>std::errc::result_out_of_range</code> if the two values when multiplied would overflow the containing value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- integer arithmetic type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_lhs</td><td>- left hand side integer </td></tr>
    <tr><td class="paramname">p_rhs</td><td>- right hand side integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;T&gt; - either the resultant or an error <code>std::errc::result_out_of_range</code> </dd></dl>

</div>
</div>
<a id="aa8aaf22d9bdddd575788368f47a33889" name="aa8aaf22d9bdddd575788368f47a33889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8aaf22d9bdddd575788368f47a33889">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; CharT, Traits &gt; &amp; hal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const hal::byte &amp;&#160;</td>
          <td class="paramname"><em>p_byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print byte type using ostreams </p>
<p >Meant for unit testing, testing and simulation purposes C++ streams, in general, should not be used for any embedded project that will ever have to be used on an MCU due to its memory cost.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CharT</td><td>- character type </td></tr>
    <tr><td class="paramname">Traits</td><td>- ostream traits type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_ostream</td><td>- the ostream </td></tr>
    <tr><td class="paramname">p_byte</td><td>- object to convert to a string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::basic_ostream&lt;CharT, Traits&gt;&amp; - reference to the ostream </dd></dl>

</div>
</div>
<a id="a72fd20564d6169140e6ac2523fb98f5f" name="a72fd20564d6169140e6ac2523fb98f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72fd20564d6169140e6ac2523fb98f5f">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; CharT, Traits &gt; &amp; hal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharT, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const work_state &amp;&#160;</td>
          <td class="paramname"><em>p_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0eba956ee13962b21698a6f68c65a74" name="aa0eba956ee13962b21698a6f68c65a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eba956ee13962b21698a6f68c65a74">&#9670;&#160;</a></span>operator==() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hal::operator== </td>
          <td>(</td>
          <td class="paramtype">const can::message_t &amp;&#160;</td>
          <td class="paramname"><em>p_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const can::message_t &amp;&#160;</td>
          <td class="paramname"><em>p_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c94d8f98d4151cf8bf474d7926bb8b9" name="a9c94d8f98d4151cf8bf474d7926bb8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c94d8f98d4151cf8bf474d7926bb8b9">&#9670;&#160;</a></span>operator==() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hal::operator== </td>
          <td>(</td>
          <td class="paramtype">const can::settings &amp;&#160;</td>
          <td class="paramname"><em>p_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const can::settings &amp;&#160;</td>
          <td class="paramname"><em>p_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a9c94d8f98d4151cf8bf474d7926bb8b9_cgraph.svg" width="250" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="af7701083fe3fdb39b9a187ca9993e9b6" name="af7701083fe3fdb39b9a187ca9993e9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7701083fe3fdb39b9a187ca9993e9b6">&#9670;&#160;</a></span>operator==() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hal::operator== </td>
          <td>(</td>
          <td class="paramtype">const i2c::settings &amp;&#160;</td>
          <td class="paramname"><em>p_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const i2c::settings &amp;&#160;</td>
          <td class="paramname"><em>p_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_af7701083fe3fdb39b9a187ca9993e9b6_cgraph.svg" width="250" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a61345e935d9024b56cf226c3dbddc6ec" name="a61345e935d9024b56cf226c3dbddc6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61345e935d9024b56cf226c3dbddc6ec">&#9670;&#160;</a></span>operator==() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hal::operator== </td>
          <td>(</td>
          <td class="paramtype">const input_pin::settings &amp;&#160;</td>
          <td class="paramname"><em>p_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const input_pin::settings &amp;&#160;</td>
          <td class="paramname"><em>p_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7595bc96003d3eaec4fe2b5c566ace1" name="ae7595bc96003d3eaec4fe2b5c566ace1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7595bc96003d3eaec4fe2b5c566ace1">&#9670;&#160;</a></span>operator==() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hal::operator== </td>
          <td>(</td>
          <td class="paramtype">const interrupt_pin::settings &amp;&#160;</td>
          <td class="paramname"><em>p_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const interrupt_pin::settings &amp;&#160;</td>
          <td class="paramname"><em>p_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a66b9e7de64519263a90bff8e094f25dd" name="a66b9e7de64519263a90bff8e094f25dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b9e7de64519263a90bff8e094f25dd">&#9670;&#160;</a></span>operator==() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hal::operator== </td>
          <td>(</td>
          <td class="paramtype">const output_pin::settings &amp;&#160;</td>
          <td class="paramname"><em>p_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_pin::settings &amp;&#160;</td>
          <td class="paramname"><em>p_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b05743dd9eeecc7fab83b6f472c9397" name="a2b05743dd9eeecc7fab83b6f472c9397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b05743dd9eeecc7fab83b6f472c9397">&#9670;&#160;</a></span>operator==() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hal::operator== </td>
          <td>(</td>
          <td class="paramtype">const serial::settings &amp;&#160;</td>
          <td class="paramname"><em>p_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const serial::settings &amp;&#160;</td>
          <td class="paramname"><em>p_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a2b05743dd9eeecc7fab83b6f472c9397_cgraph.svg" width="250" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abc0c567f9afda7f9d9e1ba91f60a83aa" name="abc0c567f9afda7f9d9e1ba91f60a83aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0c567f9afda7f9d9e1ba91f60a83aa">&#9670;&#160;</a></span>operator==() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hal::operator== </td>
          <td>(</td>
          <td class="paramtype">const spi::settings &amp;&#160;</td>
          <td class="paramname"><em>p_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const spi::settings &amp;&#160;</td>
          <td class="paramname"><em>p_rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1ce95a0f68875e29428e13cc53c3387" name="ad1ce95a0f68875e29428e13cc53c3387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ce95a0f68875e29428e13cc53c3387">&#9670;&#160;</a></span>probe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::probe </td>
          <td>(</td>
          <td class="paramtype">i2c &amp;&#160;</td>
          <td class="paramname"><em>p_i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>probe the i2c bus to see if a device exists </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_i2c</td><td>- i2c driver </td></tr>
    <tr><td class="paramname">p_address</td><td>- target address to probe for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>

</div>
</div>
<a id="a00694e558039dbf0a2e4f2a438754e10" name="a00694e558039dbf0a2e4f2a438754e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00694e558039dbf0a2e4f2a438754e10">&#9670;&#160;</a></span>read() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::read </td>
          <td>(</td>
          <td class="paramtype">i2c &amp;&#160;</td>
          <td class="paramname"><em>p_i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em> = <code>hal::never_timeout()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read bytes from target device on i2c bus </p>
<p >Shorthand for writing i2c.transfer(...) for read only operations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_i2c</td><td>- i2c driver </td></tr>
    <tr><td class="paramname">p_address</td><td>- target address </td></tr>
    <tr><td class="paramname">p_data_in</td><td>- buffer to read bytes into from target device </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- amount of time to execute the transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a00694e558039dbf0a2e4f2a438754e10_icgraph.svg" width="267" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afaee8290b9ba7d512d6f8a724e99d06c" name="afaee8290b9ba7d512d6f8a724e99d06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaee8290b9ba7d512d6f8a724e99d06c">&#9670;&#160;</a></span>read() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t BytesToRead&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; hal::read </td>
          <td>(</td>
          <td class="paramtype">i2c &amp;&#160;</td>
          <td class="paramname"><em>p_i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em> = <code>hal::never_timeout()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return array of read bytes from target device on i2c bus </p>
<p >Eliminates the need to create a buffer and pass it into the read function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BytesToRead</td><td>- number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_i2c</td><td>- i2c driver </td></tr>
    <tr><td class="paramname">p_address</td><td>- target address </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- amount of time to execute the transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; - array of bytes from target device or an error. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_afaee8290b9ba7d512d6f8a724e99d06c_cgraph.svg" width="200" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a58f116057547375e7bcdc6f29ef3786c" name="a58f116057547375e7bcdc6f29ef3786c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f116057547375e7bcdc6f29ef3786c">&#9670;&#160;</a></span>read() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; std::span&lt; hal::byte &gt; &gt; hal::read </td>
          <td>(</td>
          <td class="paramtype">serial &amp;&#160;</td>
          <td class="paramname"><em>p_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read bytes from a serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_serial</td><td>- the serial port that will be read from </td></tr>
    <tr><td class="paramname">p_data_in</td><td>- buffer to have bytes from the serial port read into </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- timeout callable that indicates when to bail out of the read operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;std::span&lt;hal::byte&gt;&gt; - return an error if a call to serial::read or <a class="el" href="namespacehal.html#a80cd2610c280e615d52e03d83dad28f6" title="Delay execution for a duration of time using a hardware steady_clock.">delay()</a> returns an error from the serial port or a span with the number of bytes read and a pointer to where the read bytes are. </dd></dl>

</div>
</div>
<a id="a1a286f05a92dbc946d4e0a79db6683da" name="a1a286f05a92dbc946d4e0a79db6683da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a286f05a92dbc946d4e0a79db6683da">&#9670;&#160;</a></span>read() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t BytesToRead&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; hal::read </td>
          <td>(</td>
          <td class="paramtype">serial &amp;&#160;</td>
          <td class="paramname"><em>p_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read bytes from a serial port and return an array. </p>
<p >This call eliminates the boiler plate of creating an array and then passing that to the read function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BytesToRead</td><td>- the number of bytes to be read from the serial port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_serial</td><td>- the serial port to be read from </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- timeout callable that indicates when to bail out of the read operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; - return an error if a call to serial::read or <a class="el" href="namespacehal.html#a80cd2610c280e615d52e03d83dad28f6" title="Delay execution for a duration of time using a hardware steady_clock.">delay()</a> returns an error from the serial port or a span with the number of bytes read and a pointer to where the read bytes are. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a1a286f05a92dbc946d4e0a79db6683da_cgraph.svg" width="200" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="afb6b09a90535fd11225c129264d20d0a" name="afb6b09a90535fd11225c129264d20d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6b09a90535fd11225c129264d20d0a">&#9670;&#160;</a></span>read() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t BytesToRead&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; hal::read </td>
          <td>(</td>
          <td class="paramtype">spi &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_filler</em> = <code>spi::default_filler</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the SPI bus and return a std::array of bytes. </p>
<p >Filler bytes will be placed on the write line.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BytesToRead</td><td>- Number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_filler</td><td>- filler data placed on the bus in place of actual write data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; - any errors associated with this call </dd></dl>

</div>
</div>
<a id="a8a7f7d46ffb8abf2bb679b1516926160" name="a8a7f7d46ffb8abf2bb679b1516926160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7f7d46ffb8abf2bb679b1516926160">&#9670;&#160;</a></span>read() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::read </td>
          <td>(</td>
          <td class="paramtype">spi &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_filler</em> = <code>spi::default_filler</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from the SPI bus. </p>
<p >Filler bytes will be placed on the write line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_data_in</td><td>- buffer to receive bytes back from the SPI bus </td></tr>
    <tr><td class="paramname">p_filler</td><td>- filler data placed on the bus in place of actual write data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>

</div>
</div>
<a id="a58a3550a3236310f20b92eacf593c2f0" name="a58a3550a3236310f20b92eacf593c2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a3550a3236310f20b92eacf593c2f0">&#9670;&#160;</a></span>rounding_division()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T hal::rounding_division </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p_numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>p_denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- integral type of the two operands </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_numerator</td><td>- the value to be divided </td></tr>
    <tr><td class="paramname">p_denominator</td><td>- the value to divide the numerator against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr T - rounded quotient between numerator and denominator. Returns 0 if the denominator is greater than the numerator. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a58a3550a3236310f20b92eacf593c2f0_cgraph.svg" width="336" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5ea8e36f9e6dbfd8e2f999c7ae052143" name="a5ea8e36f9e6dbfd8e2f999c7ae052143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea8e36f9e6dbfd8e2f999c7ae052143">&#9670;&#160;</a></span>terminated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool hal::terminated </td>
          <td>(</td>
          <td class="paramtype">byte_stream auto&#160;</td>
          <td class="paramname"><em>p_byte_stream_object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate if a byte stream object has finished its work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_byte_stream_object</td><td>- the byte stream object to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - work state is either finished or failed </dd>
<dd>
false - work state is still in progress </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a5ea8e36f9e6dbfd8e2f999c7ae052143_cgraph.svg" width="118" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a5ea8e36f9e6dbfd8e2f999c7ae052143_icgraph.svg" width="395" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a7c394730b2a8d131a48e6f033e26293c" name="a7c394730b2a8d131a48e6f033e26293c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c394730b2a8d131a48e6f033e26293c">&#9670;&#160;</a></span>terminated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool hal::terminated </td>
          <td>(</td>
          <td class="paramtype">work_state&#160;</td>
          <td class="paramname"><em>p_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1a8c1d4bb482a3798af832c843e95c1" name="ad1a8c1d4bb482a3798af832c843e95c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a8c1d4bb482a3798af832c843e95c1">&#9670;&#160;</a></span>timeout_generator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hal::timeout_generator </td>
          <td>(</td>
          <td class="paramtype">hal::steady_clock &amp;&#160;</td>
          <td class="paramname"><em>p_steady_clock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a function that, when passed a duration, returns a timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_steady_clock</td><td>- steady_clock driver that must out live the lifetime of the returned lambda. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto - a callable that returns a new timeout object each time a time duration is passed to it. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_ad1a8c1d4bb482a3798af832c843e95c1_cgraph.svg" width="558" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9e8c4111664297ec9a8af392a3ee03a4" name="a9e8c4111664297ec9a8af392a3ee03a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8c4111664297ec9a8af392a3ee03a4">&#9670;&#160;</a></span>to_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; char, N+1 &gt; hal::to_array </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>p_view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a string_view into a std::array of N number of characters. </p>
<p >Will always ensure that the array is null terminated</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>- Size of the array </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_view</td><td>- string to be placed into a char array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr std::array&lt;char, N + 1&gt; - the char array object </dd></dl>

</div>
</div>
<a id="a829d948a20f6466095edce347d7feb3b" name="a829d948a20f6466095edce347d7feb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829d948a20f6466095edce347d7feb3b">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view hal::to_string </td>
          <td>(</td>
          <td class="paramtype">work_state&#160;</td>
          <td class="paramname"><em>p_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fb2bc5d9203d47298c18293666a718b" name="a6fb2bc5d9203d47298c18293666a718b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb2bc5d9203d47298c18293666a718b">&#9670;&#160;</a></span>try_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; work_state &gt; hal::try_until </td>
          <td>(</td>
          <td class="paramtype">worker auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>p_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeatedly call a worker function until it has reached a terminal state or a timeout has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_worker</td><td>- worker function to repeatedly call </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- callable timeout object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;work_state&gt; - state of the worker function </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a6fb2bc5d9203d47298c18293666a718b_cgraph.svg" width="395" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="abd5c3782a92312131a5a7824ee6d1801" name="abd5c3782a92312131a5a7824ee6d1801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5c3782a92312131a5a7824ee6d1801">&#9670;&#160;</a></span>try_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; work_state &gt; hal::try_until </td>
          <td>(</td>
          <td class="paramtype">worker auto &amp;&#160;</td>
          <td class="paramname"><em>p_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeatedly call a worker function until it has reached a terminal state or a timeout has been reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_worker</td><td>- worker function to repeatedly call </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- callable timeout object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;work_state&gt; - state of the worker function </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_abd5c3782a92312131a5a7824ee6d1801_cgraph.svg" width="256" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_abd5c3782a92312131a5a7824ee6d1801_icgraph.svg" width="240" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa88cd03f91cf5b2ae267c13d6c86af18" name="aa88cd03f91cf5b2ae267c13d6c86af18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88cd03f91cf5b2ae267c13d6c86af18">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto hal::value </td>
          <td>(</td>
          <td class="paramtype">enumeration auto&#160;</td>
          <td class="paramname"><em>p_enum_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to convert an enum to its integral value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_enum_value</td><td>- the enumeration you want to convert into an integral value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr auto - return the integral value of the enum with the same type as the enumeration. </dd></dl>

</div>
</div>
<a id="a80ad6db29189e74fcb1a49dc801897b3" name="a80ad6db29189e74fcb1a49dc801897b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ad6db29189e74fcb1a49dc801897b3">&#9670;&#160;</a></span>wavelength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::chrono::duration&lt; int64_t, Period &gt; hal::wavelength </td>
          <td>(</td>
          <td class="paramtype">hertz&#160;</td>
          <td class="paramname"><em>p_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the wavelength in seconds. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Period</td><td>- desired period (defaults to std::femto for femtoseconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_source</td><td>- source frequency to convert to wavelength </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::chrono::duration&lt;int64_t, Period&gt; - time based wavelength of the frequency. </dd></dl>

</div>
</div>
<a id="ac884b3e7857a710a51651bf449c5dd86" name="ac884b3e7857a710a51651bf449c5dd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac884b3e7857a710a51651bf449c5dd86">&#9670;&#160;</a></span>wavelength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float hal::wavelength </td>
          <td>(</td>
          <td class="paramtype">hertz&#160;</td>
          <td class="paramname"><em>p_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the wavelength in seconds as a float. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">float_t</td><td>- float type </td></tr>
    <tr><td class="paramname">Period</td><td>- desired period </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_source</td><td>- source frequency to convert to wavelength </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr float - float representation of the time based wavelength of the frequency. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_ac884b3e7857a710a51651bf449c5dd86_cgraph.svg" width="252" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a602272331e4e2f84843e2fe34e83cca6" name="a602272331e4e2f84843e2fe34e83cca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602272331e4e2f84843e2fe34e83cca6">&#9670;&#160;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::write </td>
          <td>(</td>
          <td class="paramtype">i2c &amp;&#160;</td>
          <td class="paramname"><em>p_i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em> = <code>hal::never_timeout()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write data to a target device on the i2c bus </p>
<p >Shorthand for writing i2c.transfer(...) for write only operations</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_i2c</td><td>- i2c driver </td></tr>
    <tr><td class="paramname">p_address</td><td>- target address </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- buffer of bytes to write to the target device </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- amount of time to execute the transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a602272331e4e2f84843e2fe34e83cca6_icgraph.svg" width="270" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9686cb634f86ed068a43ea5bb5224073" name="a9686cb634f86ed068a43ea5bb5224073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9686cb634f86ed068a43ea5bb5224073">&#9670;&#160;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::write </td>
          <td>(</td>
          <td class="paramtype">serial &amp;&#160;</td>
          <td class="paramname"><em>p_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write bytes to a serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_serial</td><td>- the serial port that will be written to </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- the data to be written out the port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>

</div>
</div>
<a id="a2952837cd8d503a962e7edf748737925" name="a2952837cd8d503a962e7edf748737925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2952837cd8d503a962e7edf748737925">&#9670;&#160;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::write </td>
          <td>(</td>
          <td class="paramtype">serial &amp;&#160;</td>
          <td class="paramname"><em>p_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>p_data_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write std::span of const char to a serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_serial</td><td>- the serial port that will be written to </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- chars to be written out the port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a2952837cd8d503a962e7edf748737925_cgraph.svg" width="230" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a21efc78280c81eac00f3ef778de2dedf" name="a21efc78280c81eac00f3ef778de2dedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21efc78280c81eac00f3ef778de2dedf">&#9670;&#160;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::write </td>
          <td>(</td>
          <td class="paramtype">spi &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the SPI bus and ignore data sent from peripherals on the bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- data to be written to the SPI bus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>

</div>
</div>
<a id="a9fcfdc8a8fa26b039d5a8a6f9b6b6962" name="a9fcfdc8a8fa26b039d5a8a6f9b6b6962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcfdc8a8fa26b039d5a8a6f9b6b6962">&#9670;&#160;</a></span>write_partial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; serial::write_t &gt; hal::write_partial </td>
          <td>(</td>
          <td class="paramtype">serial &amp;&#160;</td>
          <td class="paramname"><em>p_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write bytes to a serial port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_serial</td><td>- the serial port that will be written to </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- the data to be written out the port </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;serial::write_t&gt; - get the results of the uart port write operation. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a9fcfdc8a8fa26b039d5a8a6f9b6b6962_icgraph.svg" width="311" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="adccf0a18afda016d4d6a05165bc0b0ab" name="adccf0a18afda016d4d6a05165bc0b0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccf0a18afda016d4d6a05165bc0b0ab">&#9670;&#160;</a></span>write_then_read() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::write_then_read </td>
          <td>(</td>
          <td class="paramtype">i2c &amp;&#160;</td>
          <td class="paramname"><em>p_i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em> = <code>hal::never_timeout()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write and then read bytes from target device on i2c bus </p>
<p >This API simply calls transaction. This API is here for consistency across the other other communication protocols such as SPI and serial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_i2c</td><td>- i2c driver </td></tr>
    <tr><td class="paramname">p_address</td><td>- target address </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- buffer of bytes to write to the target device </td></tr>
    <tr><td class="paramname">p_data_in</td><td>- buffer to read bytes into from target device </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- amount of time to execute the transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_adccf0a18afda016d4d6a05165bc0b0ab_icgraph.svg" width="334" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3dd61760afda4a75284d67f433a2fa50" name="a3dd61760afda4a75284d67f433a2fa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd61760afda4a75284d67f433a2fa50">&#9670;&#160;</a></span>write_then_read() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t BytesToRead&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; hal::write_then_read </td>
          <td>(</td>
          <td class="paramtype">i2c &amp;&#160;</td>
          <td class="paramname"><em>p_i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em> = <code>hal::never_timeout()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write and then return an array of read bytes from target device on i2c bus </p>
<p >Eliminates the need to create a buffer and pass it into the read function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BytesToRead</td><td>- number of bytes to read after write </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_i2c</td><td>- i2c driver </td></tr>
    <tr><td class="paramname">p_address</td><td>- target address </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- buffer of bytes to write to the target device </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- amount of time to execute the transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a3dd61760afda4a75284d67f433a2fa50_cgraph.svg" width="334" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2d9abf5cca98ceab03b2bcae88c8231a" name="a2d9abf5cca98ceab03b2bcae88c8231a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9abf5cca98ceab03b2bcae88c8231a">&#9670;&#160;</a></span>write_then_read() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; std::span&lt; hal::byte &gt; &gt; hal::write_then_read </td>
          <td>(</td>
          <td class="paramtype">serial &amp;&#160;</td>
          <td class="paramname"><em>p_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a write then read transaction over serial. </p>
<p >This is especially useful for devices that use a command and response method of communication.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_serial</td><td>- the serial port to have the transaction occur on </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- the data to be written to the port </td></tr>
    <tr><td class="paramname">p_data_in</td><td>- a buffer to receive the bytes back from the port </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- timeout callable that indicates when to bail out of the read operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure or serial::write() returns an error from the serial port or success. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a2d9abf5cca98ceab03b2bcae88c8231a_cgraph.svg" width="311" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aa56cced130d5fe0233e0035616209b52" name="aa56cced130d5fe0233e0035616209b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56cced130d5fe0233e0035616209b52">&#9670;&#160;</a></span>write_then_read() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t BytesToRead&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; hal::write_then_read </td>
          <td>(</td>
          <td class="paramtype">serial &amp;&#160;</td>
          <td class="paramname"><em>p_serial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeout auto&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a write then read transaction over serial. </p>
<p >This is especially useful for devices that use a command and response method of communication.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BytesToRead</td><td>- the number of bytes to read back </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_serial</td><td>- the serial port to have the transaction occur on </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- the data to be written to the port </td></tr>
    <tr><td class="paramname">p_timeout</td><td>- timeout callable that indicates when to bail out of the read operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; - return an error if a call to serial::read or serial::write() returns an error from the serial port or an array of read bytes. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_aa56cced130d5fe0233e0035616209b52_cgraph.svg" width="334" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ae5414224d552a6e33ad7c7a49c44bc8b" name="ae5414224d552a6e33ad7c7a49c44bc8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5414224d552a6e33ad7c7a49c44bc8b">&#9670;&#160;</a></span>write_then_read() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t BytesToRead&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; hal::write_then_read </td>
          <td>(</td>
          <td class="paramtype">spi &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_filler</em> = <code>spi::default_filler</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BytesToRead</td><td>- Number of bytes to read from the bus </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- bytes to write to the bus </td></tr>
    <tr><td class="paramname">p_filler</td><td>- filler data placed on the bus when the read operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_ae5414224d552a6e33ad7c7a49c44bc8b_cgraph.svg" width="270" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0304f6c421db748182386f3dc4547916" name="a0304f6c421db748182386f3dc4547916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0304f6c421db748182386f3dc4547916">&#9670;&#160;</a></span>write_then_read() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">status hal::write_then_read </td>
          <td>(</td>
          <td class="paramtype">spi &amp;&#160;</td>
          <td class="paramname"><em>p_spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; const hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::span&lt; hal::byte &gt;&#160;</td>
          <td class="paramname"><em>p_data_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::byte&#160;</td>
          <td class="paramname"><em>p_filler</em> = <code>spi::default_filler</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes. </p>
<p >This utility function that fits the use case of many SPI devices where a transaction is not full duplex. In many spi devices, full duplex means that as data is being written to the SPI bus, the peripheral device is sending data back on the read line. In most cases, the protocol is to write data to the bus, and ignore the read line because the peripheral is not writing anything meaningful to that line, then reading from SPI bus and writing nothing meaningful to the write line as the peripheral is ignoring that line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_spi</td><td>- spi driver </td></tr>
    <tr><td class="paramname">p_data_out</td><td>- bytes to write to the bus </td></tr>
    <tr><td class="paramname">p_data_in</td><td>- buffer to receive bytes back from the SPI bus </td></tr>
    <tr><td class="paramname">p_filler</td><td>- filler data placed on the bus when the read operation begins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status - success or failure </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacehal_a0304f6c421db748182386f3dc4547916_cgraph.svg" width="270" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehal.html">hal</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
